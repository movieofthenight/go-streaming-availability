/*
Streaming Availability API

Streaming Availability API allows getting streaming availability information of movies and series; and querying the list of available shows on streaming services such as Netflix, Disney+, Apple TV, Max and Hulu across 58 countries!

API version: 3.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package streaming

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiChangesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	country *string
	services *string
	changeType *string
	targetType *string
	since *int32
	cursor *string
	desc *bool
	outputLanguage *string
}

// [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code of the target country.
func (r ApiChangesRequest) Country(country string) ApiChangesRequest {
	r.country = &country
	return r
}

// A comma separated list of up to services to search in. See \&quot;/services\&quot; endpoint to get the supported services and their ids/names. Maximum amount of services allowed depends on the endpoint. If a service supports both \&quot;free\&quot; and \&quot;subscription\&quot;, then results included under \&quot;subscription\&quot; will always include the \&quot;free\&quot; shows as well. When multiple values are passed as a comma separated list, any show that satisfies at least one of the values will be included in the result. Syntax of the values supplied in the list can be as the followings: - \&quot;&lt;sevice_id&gt;\&quot;: Searches in the entire catalog of that service, including (if applicable) rentable, buyable shows or shows available through addons i.e. \&quot;netflix\&quot;, \&quot;prime\&quot;, \&quot;apple\&quot; - \&quot;&lt;sevice_id&gt;.&lt;streaming_type&gt;\&quot;: Only returns the shows that are available in that service with the given streaming type. Valid streaming type values are \&quot;subscription\&quot;, \&quot;free\&quot;, \&quot;rent\&quot;, \&quot;buy\&quot; and \&quot;addon\&quot; i.e. \&quot;peacock.free\&quot; only returns the shows on Peacock that are free to watch, \&quot;prime.subscription\&quot; only returns the shows on Prime Video that are available to watch with a Prime subscription. \&quot;hulu.addon\&quot; only returns the shows on Hulu that are available via an addon, \&quot;prime.rent\&quot; only returns the shows on Prime Video that are rentable. - \&quot;&lt;sevice_id&gt;.addon.&lt;addon_id&gt;\&quot;: Only returns the shows that are available in that service with the given addon. Check \&quot;/services\&quot; endpoint to fetch the available addons for a service. Some sample values are: \&quot;hulu.addon.hbo\&quot;, \&quot;prime.addon.hbomaxus\&quot;. 
func (r ApiChangesRequest) Services(services string) ApiChangesRequest {
	r.services = &services
	return r
}

// Type of change to query.
func (r ApiChangesRequest) ChangeType(changeType string) ApiChangesRequest {
	r.changeType = &changeType
	return r
}

// Type of items to search in.
func (r ApiChangesRequest) TargetType(targetType string) ApiChangesRequest {
	r.targetType = &targetType
	return r
}

// [Unix Time Stamp](https://www.unixtimestamp.com/) to only query the changes since then. Must be within the past \&quot;31\&quot; days. If not supplied, the changes withing the past \&quot;15\&quot; days are returned. 
func (r ApiChangesRequest) Since(since int32) ApiChangesRequest {
	r.since = &since
	return r
}

// Cursor is used for pagination. After each request, the response includes a \&quot;hasMore\&quot; boolean field to tell if there are more results that did not fit into the returned list. If it is set as \&quot;true\&quot;, to get the rest of the result set, send a new request (with the same parameters for other fields such as \&quot;services\&quot; etc.), and set the \&quot;cursor\&quot; parameter as the \&quot;nextCursor\&quot; value of the previous request response. Do not forget to escape the \&quot;cursor\&quot; value before putting it into a query as it might contain characters such as \&quot;?\&quot;and \&quot;&amp;\&quot;. The first request naturally does not require a \&quot;cursor\&quot; parameter. 
func (r ApiChangesRequest) Cursor(cursor string) ApiChangesRequest {
	r.cursor = &cursor
	return r
}

// The results are ordered in descending order if set true.
func (r ApiChangesRequest) Desc(desc bool) ApiChangesRequest {
	r.desc = &desc
	return r
}

// [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code of the output language. Determines in which language the output field \&quot;title\&quot; will be in. It also effects how the keyword input will be handled in search endpoints. (i.e. if \&quot;output_language\&quot; is \&quot;es\&quot;, then the \&quot;keyword\&quot; will be treated as a Spanish word). 
func (r ApiChangesRequest) OutputLanguage(outputLanguage string) ApiChangesRequest {
	r.outputLanguage = &outputLanguage
	return r
}

func (r ApiChangesRequest) Execute() (*ChangesResponseSchema, *http.Response, error) {
	return r.ApiService.ChangesExecute(r)
}

/*
Changes Changes

Query the new, removed or updated movies/series/seasons/episodes in a given list of streaming services. Results are ordered by the date of the changes. Changes listed per page is "25" when "target_type" is "show", "movie" or "series"; "50" when it is "season"; and "100" when it is "episode".
Note that changes for the same show are aggregated together into a single "changes" array for that show. Which means there might be cases where the count of the items in the result array might be fewer than the maximum changes listed per page. (i.e. When "target_type" is "season", there might be 10 items in the result array, but the overall total number of changes listed across the "changes" arrays will be still 50, given that there are at least 50 changes matches with the given query.)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangesRequest
*/
func (a *DefaultApiService) Changes(ctx context.Context) ApiChangesRequest {
	return ApiChangesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangesResponseSchema
func (a *DefaultApiService) ChangesExecute(r ApiChangesRequest) (*ChangesResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangesResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Changes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/changes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}
	if r.services == nil {
		return localVarReturnValue, nil, reportError("services is required and must be specified")
	}
	if r.changeType == nil {
		return localVarReturnValue, nil, reportError("changeType is required and must be specified")
	}
	if r.targetType == nil {
		return localVarReturnValue, nil, reportError("targetType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "services", r.services, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "change_type", r.changeType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "target_type", r.targetType, "")
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.desc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "desc", r.desc, "")
	}
	if r.outputLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "output_language", r.outputLanguage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Rapid-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-RapidAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenresRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiGenresRequest) Execute() (*GenresResponseSchema, *http.Response, error) {
	return r.ApiService.GenresExecute(r)
}

/*
Genres Genres

Get the ids and names of the supported genres.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenresRequest
*/
func (a *DefaultApiService) Genres(ctx context.Context) ApiGenresRequest {
	return ApiGenresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenresResponseSchema
func (a *DefaultApiService) GenresExecute(r ApiGenresRequest) (*GenresResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenresResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Genres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genres"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Rapid-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-RapidAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetByIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	imdbId *string
	tmdbId *string
	outputLanguage *string
}

// IMDb ID of the target show. Either this or \&quot;tmdb_id\&quot; parameter must be supplied.
func (r ApiGetByIdRequest) ImdbId(imdbId string) ApiGetByIdRequest {
	r.imdbId = &imdbId
	return r
}

// TMDb ID of the target show. Either this or \&quot;imdb_id\&quot; parameter must be supplied
func (r ApiGetByIdRequest) TmdbId(tmdbId string) ApiGetByIdRequest {
	r.tmdbId = &tmdbId
	return r
}

// [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code of the output language. Determines in which language the output field \&quot;title\&quot; will be in. It also effects how the keyword input will be handled in search endpoints. (i.e. if \&quot;output_language\&quot; is \&quot;es\&quot;, then the \&quot;keyword\&quot; will be treated as a Spanish word). 
func (r ApiGetByIdRequest) OutputLanguage(outputLanguage string) ApiGetByIdRequest {
	r.outputLanguage = &outputLanguage
	return r
}

func (r ApiGetByIdRequest) Execute() (*GetResponseSchema, *http.Response, error) {
	return r.ApiService.GetByIdExecute(r)
}

/*
GetById Get by Id

Get the details of a show via IMDb or TMDb id, including the global streaming availability info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetByIdRequest
*/
func (a *DefaultApiService) GetById(ctx context.Context) ApiGetByIdRequest {
	return ApiGetByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetResponseSchema
func (a *DefaultApiService) GetByIdExecute(r ApiGetByIdRequest) (*GetResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imdb_id", r.imdbId, "")
	}
	if r.tmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tmdb_id", r.tmdbId, "")
	}
	if r.outputLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "output_language", r.outputLanguage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Rapid-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-RapidAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundResponseSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLeavingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	country *string
	services *string
	targetType *string
	cursor *string
	outputLanguage *string
}

// [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code of the target country.
func (r ApiLeavingRequest) Country(country string) ApiLeavingRequest {
	r.country = &country
	return r
}

// A comma separated list of up to services to search in. See \&quot;/services\&quot; endpoint to get the supported services and their ids/names. Maximum amount of services allowed depends on the endpoint. If a service supports both \&quot;free\&quot; and \&quot;subscription\&quot;, then results included under \&quot;subscription\&quot; will always include the \&quot;free\&quot; shows as well. When multiple values are passed as a comma separated list, any show that satisfies at least one of the values will be included in the result. Syntax of the values supplied in the list can be as the followings: - \&quot;&lt;sevice_id&gt;\&quot;: Searches in the entire catalog of that service, including (if applicable) rentable, buyable shows or shows available through addons i.e. \&quot;netflix\&quot;, \&quot;prime\&quot;, \&quot;apple\&quot; - \&quot;&lt;sevice_id&gt;.&lt;streaming_type&gt;\&quot;: Only returns the shows that are available in that service with the given streaming type. Valid streaming type values are \&quot;subscription\&quot;, \&quot;free\&quot;, \&quot;rent\&quot;, \&quot;buy\&quot; and \&quot;addon\&quot; i.e. \&quot;peacock.free\&quot; only returns the shows on Peacock that are free to watch, \&quot;prime.subscription\&quot; only returns the shows on Prime Video that are available to watch with a Prime subscription. \&quot;hulu.addon\&quot; only returns the shows on Hulu that are available via an addon, \&quot;prime.rent\&quot; only returns the shows on Prime Video that are rentable. - \&quot;&lt;sevice_id&gt;.addon.&lt;addon_id&gt;\&quot;: Only returns the shows that are available in that service with the given addon. Check \&quot;/services\&quot; endpoint to fetch the available addons for a service. Some sample values are: \&quot;hulu.addon.hbo\&quot;, \&quot;prime.addon.hbomaxus\&quot;. 
func (r ApiLeavingRequest) Services(services string) ApiLeavingRequest {
	r.services = &services
	return r
}

// Type of items to search in.
func (r ApiLeavingRequest) TargetType(targetType string) ApiLeavingRequest {
	r.targetType = &targetType
	return r
}

// Cursor is used for pagination. After each request, the response includes a \&quot;hasMore\&quot; boolean field to tell if there are more results that did not fit into the returned list. If it is set as \&quot;true\&quot;, to get the rest of the result set, send a new request (with the same parameters for other fields such as \&quot;services\&quot; etc.), and set the \&quot;cursor\&quot; parameter as the \&quot;nextCursor\&quot; value of the previous request response. Do not forget to escape the \&quot;cursor\&quot; value before putting it into a query as it might contain characters such as \&quot;?\&quot;and \&quot;&amp;\&quot;. The first request naturally does not require a \&quot;cursor\&quot; parameter. 
func (r ApiLeavingRequest) Cursor(cursor string) ApiLeavingRequest {
	r.cursor = &cursor
	return r
}

// [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code of the output language. Determines in which language the output field \&quot;title\&quot; will be in. It also effects how the keyword input will be handled in search endpoints. (i.e. if \&quot;output_language\&quot; is \&quot;es\&quot;, then the \&quot;keyword\&quot; will be treated as a Spanish word). 
func (r ApiLeavingRequest) OutputLanguage(outputLanguage string) ApiLeavingRequest {
	r.outputLanguage = &outputLanguage
	return r
}

func (r ApiLeavingRequest) Execute() (*UpcomingChangesResponseSchema, *http.Response, error) {
	return r.ApiService.LeavingExecute(r)
}

/*
Leaving Leaving

Query for the leaving movies/series/seasons/episodes in a given list of streaming services. Results are ordered by the last day to watch. Changes listed per page is "25" when "target_type" is "show", "movie" or "series"; "50" when it is "season"; and "100" when it is "episode".
Note that upcoming changes for the same show are aggregated together into a single "upcomingChanges" array for that show. Which means there might be cases where the count of the items in the result array might be fewer than the maximum upcoming changes listed per page. (i.e. When "target_type" is "season", there might be 10 items in the result array, but the overall total number of upcoming changes listed across the "upcomingChanges" arrays will be still 50, given that there are at least 50 upcoming changes matches with the given query.)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLeavingRequest
*/
func (a *DefaultApiService) Leaving(ctx context.Context) ApiLeavingRequest {
	return ApiLeavingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpcomingChangesResponseSchema
func (a *DefaultApiService) LeavingExecute(r ApiLeavingRequest) (*UpcomingChangesResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpcomingChangesResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Leaving")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/leaving"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}
	if r.services == nil {
		return localVarReturnValue, nil, reportError("services is required and must be specified")
	}
	if r.targetType == nil {
		return localVarReturnValue, nil, reportError("targetType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "services", r.services, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "target_type", r.targetType, "")
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.outputLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "output_language", r.outputLanguage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Rapid-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-RapidAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchByFiltersRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	country *string
	services *string
	outputLanguage *string
	showType *string
	genres *string
	genresRelation *string
	showOriginalLanguage *string
	yearMin *int32
	yearMax *int32
	keyword *string
	orderBy *string
	desc *bool
	cursor *string
}

// [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code of the target country.
func (r ApiSearchByFiltersRequest) Country(country string) ApiSearchByFiltersRequest {
	r.country = &country
	return r
}

// A comma separated list of up to services to search in. See \&quot;/services\&quot; endpoint to get the supported services and their ids/names. Maximum amount of services allowed depends on the endpoint. If a service supports both \&quot;free\&quot; and \&quot;subscription\&quot;, then results included under \&quot;subscription\&quot; will always include the \&quot;free\&quot; shows as well. When multiple values are passed as a comma separated list, any show that satisfies at least one of the values will be included in the result. Syntax of the values supplied in the list can be as the followings: - \&quot;&lt;sevice_id&gt;\&quot;: Searches in the entire catalog of that service, including (if applicable) rentable, buyable shows or shows available through addons i.e. \&quot;netflix\&quot;, \&quot;prime\&quot;, \&quot;apple\&quot; - \&quot;&lt;sevice_id&gt;.&lt;streaming_type&gt;\&quot;: Only returns the shows that are available in that service with the given streaming type. Valid streaming type values are \&quot;subscription\&quot;, \&quot;free\&quot;, \&quot;rent\&quot;, \&quot;buy\&quot; and \&quot;addon\&quot; i.e. \&quot;peacock.free\&quot; only returns the shows on Peacock that are free to watch, \&quot;prime.subscription\&quot; only returns the shows on Prime Video that are available to watch with a Prime subscription. \&quot;hulu.addon\&quot; only returns the shows on Hulu that are available via an addon, \&quot;prime.rent\&quot; only returns the shows on Prime Video that are rentable. - \&quot;&lt;sevice_id&gt;.addon.&lt;addon_id&gt;\&quot;: Only returns the shows that are available in that service with the given addon. Check \&quot;/services\&quot; endpoint to fetch the available addons for a service. Some sample values are: \&quot;hulu.addon.hbo\&quot;, \&quot;prime.addon.hbomaxus\&quot;. 
func (r ApiSearchByFiltersRequest) Services(services string) ApiSearchByFiltersRequest {
	r.services = &services
	return r
}

// [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code of the output language. Determines in which language the output field \&quot;title\&quot; will be in. It also effects how the keyword input will be handled in search endpoints. (i.e. if \&quot;output_language\&quot; is \&quot;es\&quot;, then the \&quot;keyword\&quot; will be treated as a Spanish word). 
func (r ApiSearchByFiltersRequest) OutputLanguage(outputLanguage string) ApiSearchByFiltersRequest {
	r.outputLanguage = &outputLanguage
	return r
}

// Type of shows to search in.
func (r ApiSearchByFiltersRequest) ShowType(showType string) ApiSearchByFiltersRequest {
	r.showType = &showType
	return r
}

// A comma seperated list of genre ids to only search within the shows in those genre. See \&quot;/genres\&quot; endpoint to see the available genres and their ids. Use \&quot;genres_relation\&quot; parameter to specify between returning shows that have at least one of the given genres or returning shows that have all of the given genres. 
func (r ApiSearchByFiltersRequest) Genres(genres string) ApiSearchByFiltersRequest {
	r.genres = &genres
	return r
}

// Only used when there are multiple genres supplied in \&quot;genres\&quot; parameter. When \&quot;or\&quot;, the endpoint returns any show that has at least one of the given genres. When \&quot;and\&quot;, it only returns the shows that have all of the given genres. 
func (r ApiSearchByFiltersRequest) GenresRelation(genresRelation string) ApiSearchByFiltersRequest {
	r.genresRelation = &genresRelation
	return r
}

// [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code to only search within the shows whose original language matches with the provided language. 
func (r ApiSearchByFiltersRequest) ShowOriginalLanguage(showOriginalLanguage string) ApiSearchByFiltersRequest {
	r.showOriginalLanguage = &showOriginalLanguage
	return r
}

// Minimum release/air year of the shows.
func (r ApiSearchByFiltersRequest) YearMin(yearMin int32) ApiSearchByFiltersRequest {
	r.yearMin = &yearMin
	return r
}

// Maximum release/air year of the shows.
func (r ApiSearchByFiltersRequest) YearMax(yearMax int32) ApiSearchByFiltersRequest {
	r.yearMax = &yearMax
	return r
}

// A keyword to only search within the shows have that keyword in their overview or title.
func (r ApiSearchByFiltersRequest) Keyword(keyword string) ApiSearchByFiltersRequest {
	r.keyword = &keyword
	return r
}

// Determines the ordering of the results.
func (r ApiSearchByFiltersRequest) OrderBy(orderBy string) ApiSearchByFiltersRequest {
	r.orderBy = &orderBy
	return r
}

// The results are ordered in descending order if set true.
func (r ApiSearchByFiltersRequest) Desc(desc bool) ApiSearchByFiltersRequest {
	r.desc = &desc
	return r
}

// Cursor is used for pagination. After each request, the response includes a \&quot;hasMore\&quot; boolean field to tell if there are more results that did not fit into the returned list. If it is set as \&quot;true\&quot;, to get the rest of the result set, send a new request (with the same parameters for other fields such as \&quot;services\&quot; etc.), and set the \&quot;cursor\&quot; parameter as the \&quot;nextCursor\&quot; value of the previous request response. Do not forget to escape the \&quot;cursor\&quot; value before putting it into a query as it might contain characters such as \&quot;?\&quot;and \&quot;&amp;\&quot;. The first request naturally does not require a \&quot;cursor\&quot; parameter. 
func (r ApiSearchByFiltersRequest) Cursor(cursor string) ApiSearchByFiltersRequest {
	r.cursor = &cursor
	return r
}

func (r ApiSearchByFiltersRequest) Execute() (*SearchFiltersResponseSchema, *http.Response, error) {
	return r.ApiService.SearchByFiltersExecute(r)
}

/*
SearchByFilters Search by Filters

Search through the catalog of the given streaming services in the given country. Provides filters such as show language, genre, keyword and release year. Items per page is "25". Can pass up to "16" services in the "services" parameter Output includes all the information about the shows, such as title, IMDb ID, TMDb ID, release year, link to shows' pages in streaming services (including individual season/episode links), available subtitles, audios, available video quality and many more! Apart from the info about the given country-service combinations, output also includes information about streaming availability in the other services for the given country.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchByFiltersRequest
*/
func (a *DefaultApiService) SearchByFilters(ctx context.Context) ApiSearchByFiltersRequest {
	return ApiSearchByFiltersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchFiltersResponseSchema
func (a *DefaultApiService) SearchByFiltersExecute(r ApiSearchByFiltersRequest) (*SearchFiltersResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchFiltersResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SearchByFilters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search/filters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}
	if r.services == nil {
		return localVarReturnValue, nil, reportError("services is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "services", r.services, "")
	if r.outputLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "output_language", r.outputLanguage, "")
	}
	if r.showType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_type", r.showType, "")
	}
	if r.genres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genres", r.genres, "")
	}
	if r.genresRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genres_relation", r.genresRelation, "")
	}
	if r.showOriginalLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_original_language", r.showOriginalLanguage, "")
	}
	if r.yearMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "year_min", r.yearMin, "")
	}
	if r.yearMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "year_max", r.yearMax, "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.desc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "desc", r.desc, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Rapid-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-RapidAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchByTitleRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	title *string
	country *string
	showType *string
	outputLanguage *string
}

// Title phrase to search for.
func (r ApiSearchByTitleRequest) Title(title string) ApiSearchByTitleRequest {
	r.title = &title
	return r
}

// [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code of the target country.
func (r ApiSearchByTitleRequest) Country(country string) ApiSearchByTitleRequest {
	r.country = &country
	return r
}

// Type of shows to search in.
func (r ApiSearchByTitleRequest) ShowType(showType string) ApiSearchByTitleRequest {
	r.showType = &showType
	return r
}

// [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code of the output language. Determines in which language the output field \&quot;title\&quot; will be in. It also effects how the keyword input will be handled in search endpoints. (i.e. if \&quot;output_language\&quot; is \&quot;es\&quot;, then the \&quot;keyword\&quot; will be treated as a Spanish word). 
func (r ApiSearchByTitleRequest) OutputLanguage(outputLanguage string) ApiSearchByTitleRequest {
	r.outputLanguage = &outputLanguage
	return r
}

func (r ApiSearchByTitleRequest) Execute() (*SearchTitleResponseSchema, *http.Response, error) {
	return r.ApiService.SearchByTitleExecute(r)
}

/*
SearchByTitle Search by Title

Search for movies and series by a title. Maximum amount of items returned are "25" unless there are more than 25 shows with the exact given title input. In that case all the items have 100% match with the title will be returned.
No pagination is supported.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchByTitleRequest
*/
func (a *DefaultApiService) SearchByTitle(ctx context.Context) ApiSearchByTitleRequest {
	return ApiSearchByTitleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchTitleResponseSchema
func (a *DefaultApiService) SearchByTitleExecute(r ApiSearchByTitleRequest) (*SearchTitleResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchTitleResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SearchByTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search/title"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "")
	if r.showType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_type", r.showType, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	if r.outputLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "output_language", r.outputLanguage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Rapid-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-RapidAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServicesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiServicesRequest) Execute() (*ServicesResponseSchema, *http.Response, error) {
	return r.ApiService.ServicesExecute(r)
}

/*
Services Services

Get all the supported streaming services, list of the supported countries for each service and other related details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesRequest
*/
func (a *DefaultApiService) Services(ctx context.Context) ApiServicesRequest {
	return ApiServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServicesResponseSchema
func (a *DefaultApiService) ServicesExecute(r ApiServicesRequest) (*ServicesResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicesResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Services")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Rapid-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-RapidAPI-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
